Documentaci√≥n de Tarea: C√°mara de Seguimiento para Bola de Boliche
Este documento contiene la interacci√≥n completa con la IA para solicitar la soluci√≥n a un problema de seguimiento de c√°mara en Unity, la gu√≠a de implementaci√≥n y el c√≥digo final.

1. Solicitud (Prompt) Enviado a la IA
Rol Solicitado: Desarrollador de videojuegos de Unity 3D.

Problema Expuesto: "Estoy realizando un juego de boliche 3D, quiero una c√°mara de seguimiento para la bola de boliche. Basado en el siguiente c√≥digo [C√ìDIGO DE CONTROLBOLA ORIGINAL] dame una gu√≠a paso a paso de c√≥mo implementarlo en unity. Y dame el c√≥digo completo para la c√°mara y la bola."

C√≥digo de ControlBola Original:

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;

public class ControlBola : MonoBehaviour
{
    public Transform CamaraPrincipal;
    public Rigidbody rb;
    //Variables para apuntar
    public float velocidadDeApuntado = 5f;
    public float limiteIzquierdo = -2f;
    public float limiteDerecho = 2f;
    public float fuerzaDeLanzamiento = 1000f;
    private bool haSidoLanzada = false;

    void Start()
    {
    }

    void Update()
    {
        //Expresi√≥n: mientras que haSidoLanzada sea falso puedes disparar.
        if (haSidoLanzada == false)
        {
            Apuntar();
            if (Input.GetKeyDown(KeyCode.Space))
            {
                Lanzar();
            }
        }
    }

    void Apuntar()
    {
        float inputHorizontal = Input.GetAxis("Horizontal");
        transform.Translate(Vector3.right * inputHorizontal * velocidadDeApuntado * Time.deltaTime);

        Vector3 posicionActual = transform.position;
        posicionActual.x = Mathf.Clamp(posicionActual.x, limiteIzquierdo, limiteDerecho);
        transform.position = posicionActual;
    }

    void Lanzar()
    {
        haSidoLanzada = true;
        rb.AddForce(Vector3.forward * fuerzaDeLanzamiento);

        if (CamaraPrincipal != null)
        {
            CamaraPrincipal.SetParent(transform); // <-- Esta l√≠nea causa la rotaci√≥n indeseada
        }
    }
}

Problema Adicional: "Actualmente con esa script la camara sigue la bola pero roda con ella, yo solo quiero que la siga sin que la camara ruede como la bola."



2. Soluci√≥n de la IA y Gu√≠a de Implementaci√≥n
La causa del problema es usar CamaraPrincipal.SetParent(transform);, lo que hace que la c√°mara herede la rotaci√≥n de la bola. La soluci√≥n es eliminar esa l√≠nea y usar un script dedicado de seguimiento en LateUpdate.

üõ†Ô∏è Gu√≠a Paso a Paso para la C√°mara de Seguimiento
Preparaci√≥n del Script ControlBola: Eliminar la l√≠nea CamaraPrincipal.SetParent(transform); de la funci√≥n Lanzar().

Creaci√≥n del Script SeguimientoCamara: Crear un nuevo script en el proyecto con ese nombre.

Implementaci√≥n del C√≥digo de Seguimiento: Pegar el c√≥digo de SeguimientoCamara.cs (ver secci√≥n 2.3) en el nuevo archivo.

Configuraci√≥n de la Jerarqu√≠a de Unity:

Adjuntar el script SeguimientoCamara al objeto Main Camera.

En el Inspector de la Main Camera, arrastrar el objeto de la Bola de Boliche al slot Objetivo.

Ajuste de Posici√≥n (Offset): Colocar la c√°mara en la escena a la posici√≥n deseada (detr√°s y encima de la bola) y luego copiar esos valores de posici√≥n (X, Y, Z) al slot Offset del script SeguimientoCamara en el Inspector.



2.1. C√≥digo Corregido de la Bola (ControlBola.cs)
Este es el c√≥digo final que debe ir en la carpeta Scripts.

C#

using UnityEngine;

public class ControlBola : MonoBehaviour
{
    // Ya NO se necesita la variable CamaraPrincipal aqu√≠
    // public Transform CamaraPrincipal; 

    public Rigidbody rb;
    public float velocidadDeApuntado = 5f;
    public float limiteIzquierdo = -2f;
    public float limiteDerecho = 2f;
    public float fuerzaDeLanzamiento = 1000f;

    private bool haSidoLanzada = false;

    void Start()
    {
        if (rb == null)
        {
            rb = GetComponent<Rigidbody>();
        }
    }

    void Update()
    {
        if (haSidoLanzada == false)
        {
            Apuntar();
            if (Input.GetKeyDown(KeyCode.Space))
            {
                Lanzar();
            }
        }
    }

    void Apuntar()
    {
        float inputHorizontal = Input.GetAxis("Horizontal");
        transform.Translate(Vector3.right * inputHorizontal * velocidadDeApuntado * Time.deltaTime);

        Vector3 posicionActual = transform.position;
        posicionActual.x = Mathf.Clamp(posicionActual.x, limiteIzquierdo, limiteDerecho);
        transform.position = posicionActual;
    }

    void Lanzar()
    {
        haSidoLanzada = true;
        rb.AddForce(Vector3.forward * fuerzaDeLanzamiento);

        // ¬°L√çNEA ELIMINADA! Ya no se hace la c√°mara hija de la bola.
        // if(CamaraPrincipal !=null)
        // {
        //     CamaraPrincipal.SetParent(transform);
        // }
    }
}



2.2. Nuevo Script de C√°mara (SeguimientoCamara.cs)
Este script usa LateUpdate para asegurar un movimiento suave y libre de rotaciones indeseadas. Este es el c√≥digo que debe ir en la carpeta Scripts.

C#

using UnityEngine;

public class SeguimientoCamara : MonoBehaviour
{
    // El Transform de la bola que queremos seguir
    public Transform Objetivo; 

    // Distancia fija que queremos mantener con respecto a la bola (ej: detr√°s 5u, arriba 2u)
    public Vector3 Offset = new Vector3(0f, 2f, -5f); 

    // Suavidad del seguimiento. Mayor valor = m√°s r√°pido.
    public float Suavidad = 5f; 

    void LateUpdate()
    {
        if (Objetivo == null)
        {
            Debug.LogError("El script SeguimientoCamara necesita un 'Objetivo' (la bola) asignado en el Inspector.");
            return;
        }

        // 1. Calculamos la posici√≥n deseada (posici√≥n de la bola + el Offset)
        Vector3 posicionDeseada = Objetivo.position + Offset;

        // 2. Aplicamos un movimiento suave (Vector3.Lerp)
        Vector3 posicionSuavizada = Vector3.Lerp(transform.position, posicionDeseada, Suavidad * Time.deltaTime);

        // 3. Aplicamos la nueva posici√≥n a la c√°mara
        transform.position = posicionSuavizada;

        // 4. Mantenemos la c√°mara mirando hacia el frente de la pista, o hacia la bola (opcional)
        // transform.LookAt(Objetivo);
    }
}